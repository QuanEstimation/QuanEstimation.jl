var documenterSearchIndex = {"docs":
[{"location":"api/BaseAPI/#Base-API","page":"Base API","title":"Base API","text":"","category":"section"},{"location":"api/BaseAPI/","page":"Base API","title":"Base API","text":"CurrentModule = QuanEstimationBase","category":"page"},{"location":"api/BaseAPI/","page":"Base API","title":"Base API","text":"Modules = [QuanEstimationBase]","category":"page"},{"location":"api/BaseAPI/#QuanEstimationBase.AD-Tuple{}","page":"Base API","title":"QuanEstimationBase.AD","text":"AD(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)\n\nOptimization algorithm: AD.\n\nmax_episode: The number of episodes.\nepsilon: Learning rate.\nbeta1: The exponential decay rate for the first moment estimates.\nbeta2: The exponential decay rate for the second moment estimates.\nAdam: Whether or not to use Adam for updating control coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.CFIM_obj-Tuple{}","page":"Base API","title":"QuanEstimationBase.CFIM_obj","text":"CFIM_obj(;M=nothing, W=nothing, eps=GLOBAL_EPS)\n\nChoose CFI [mathrmTr(WI^-1)] as the objective function with W the weight matrix and I the CFIM.\n\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\nW: Weight matrix.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.CMopt","page":"Base API","title":"QuanEstimationBase.CMopt","text":"CMopt(ctrl=nothing, M=nothing, ctrl_bound=[-Inf, Inf], seed=1234)\n\nControl and measurement optimization.\n\nctrl: Guessed control coefficients.\nM: Guessed projective measurement (a set of basis)\nctrl_bound: Lower and upper bounds of the control coefficients.\nseed: Random seed.\n\n\n\n\n\n","category":"type"},{"location":"api/BaseAPI/#QuanEstimationBase.ControlOpt-Tuple{}","page":"Base API","title":"QuanEstimationBase.ControlOpt","text":"ControlOpt(ctrl=nothing, ctrl_bound=[-Inf, Inf], seed=1234)\n\nControl optimization.\n\nctrl: Guessed control coefficients.\nctrl_bound: Lower and upper bounds of the control coefficients.\nseed: Random seed.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.DDPG-Tuple{}","page":"Base API","title":"QuanEstimationBase.DDPG","text":"DDPG(;max_episode::Int=500, layer_num::Int=3, layer_dim::Int=200, seed::Number=1234)\n\nOptimization algorithm: DE.\n\nmax_episode: The number of populations.\nlayer_num: The number of layers (include the input and output layer).\nlayer_dim: The number of neurons in the hidden layer.\nseed: Random seed.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.DE-Tuple{}","page":"Base API","title":"QuanEstimationBase.DE","text":"DE(;max_episode::Number=1000, p_num::Number=10, ini_population=nothing, c::Number=1.0, cr::Number=0.5, seed::Number=1234)\n\nOptimization algorithm: DE.\n\nmax_episode: The number of populations.\np_num: The number of particles. \nini_population: Initial guesses of the optimization variables.\nc: Mutation constant.\ncr: Crossover constant.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.GRAPE-Tuple{}","page":"Base API","title":"QuanEstimationBase.GRAPE","text":"GRAPE(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)\n\nControl optimization algorithm: GRAPE.\n\nmax_episode: The number of episodes.\nepsilon: Learning rate.\nbeta1: The exponential decay rate for the first moment estimates.\nbeta2: The exponential decay rate for the second moment estimates.\nAdam: Whether or not to use Adam for updating control coefficients.   \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.HCRB_obj-Tuple{}","page":"Base API","title":"QuanEstimationBase.HCRB_obj","text":"HCRB_obj(;W=nothing, eps=GLOBAL_EPS)\n\nChoose HCRB as the objective function. \n\nW: Weight matrix.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.LLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.LLD","text":"LLD(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T<:Complex}\n\nCalculate the left logarrithmic derivatives (LLDs). The LLD operator is defined as partial_arho=mathcalR_a^daggerrho, where ρ is the parameterized density matrix.    \n\nρ: Density matrix.\ndρ: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.\nrep: Representation of the LLD operator. Options can be: \"original\" (default) and \"eigen\".\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.LLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.LLD","text":"LLD(ρ::Matrix{T}, dρ::Matrix{T}; rep=\"original\", eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen applied to the case of single parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.NM-Tuple{}","page":"Base API","title":"QuanEstimationBase.NM","text":"NM(;max_episode::Int=1000, p_num::Int=10, nelder_mead=nothing, ar::Number=1.0, ae::Number=2.0, ac::Number=0.5, as0::Number=0.5, seed::Number=1234)\n\nState optimization algorithm: NM.\n\nmax_episode: The number of populations.\np_num: The number of the input states.\nnelder_mead: Initial guesses of the optimization variables.\nar: Reflection constant.\nae: Expansion constant.\nac: Constraction constant.\nas0: Shrink constant.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.PSO-Tuple{}","page":"Base API","title":"QuanEstimationBase.PSO","text":"PSO(;max_episode::Union{T,Vector{T}} where {T<:Int}=[1000, 100], p_num::Number=10, ini_particle=nothing, c0::Number=1.0, c1::Number=2.0, c2::Number=2.0, seed::Number=1234)\n\nOptimization algorithm: PSO.\n\nmax_episode: The number of episodes, it accepts both integer and array with two elements.\np_num: The number of particles. \nini_particle: Initial guesses of the optimization variables.\nc0: The damping factor that assists convergence, also known as inertia weight.\nc1: The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor.\nc2: The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QFIM_obj-Tuple{}","page":"Base API","title":"QuanEstimationBase.QFIM_obj","text":"QFIM_obj(;W=nothing, eps=GLOBAL_EPS, LDtype::Symbol=:SLD)\n\nChoose QFI [mathrmTr(WF^-1)] as the objective function with W the weight matrix and F the QFIM.\n\nW: Weight matrix.\neps: Machine epsilon.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.RI-Tuple{}","page":"Base API","title":"QuanEstimationBase.RI","text":"RI(;max_episode::Int=300, seed::Number=1234)\n\nState optimization algorithm: RI.\n\nmax_episode: The number of episodes.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.RLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.RLD","text":"RLD(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T<:Complex}\n\nCalculate the right logarrithmic derivatives (RLDs). The RLD operator is defined as  partial_arho=rho mathcalR_a, where rho is the parameterized density matrix.  \n\nρ: Density matrix.\ndρ: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.\nrep: Representation of the RLD operator. Options can be: \"original\" (default) and \"eigen\".\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.RLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.RLD","text":"RLD(ρ::Matrix{T}, dρ::Matrix{T}; rep=\"original\", eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen applied to the case of single parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.SCMopt","page":"Base API","title":"QuanEstimationBase.SCMopt","text":"SCMopt(psi=nothing, ctrl=nothing, M=nothing, ctrl_bound=[-Inf, Inf], seed=1234)\n\nState, control and measurement optimization.\n\npsi: Guessed probe state.\nctrl: Guessed control coefficients.\nM: Guessed projective measurement (a set of basis).\nctrl_bound:  Lower and upper bounds of the control coefficients.\nseed: Random seed.\n\n\n\n\n\n","category":"type"},{"location":"api/BaseAPI/#QuanEstimationBase.SCopt","page":"Base API","title":"QuanEstimationBase.SCopt","text":"SCopt(psi=nothing, ctrl=nothing, ctrl_bound=[-Inf, Inf], seed=1234)\n\nState and control optimization.\n\npsi: Guessed probe state.\nctrl: Guessed control coefficients.\nctrl_bound: Lower and upper bounds of the control coefficients.\nseed: Random seed.\n\n\n\n\n\n","category":"type"},{"location":"api/BaseAPI/#QuanEstimationBase.SLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.SLD","text":"SLD(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T<:Complex}\n\nCalculate the symmetric logarrithmic derivatives (SLDs). The SLD operator L_a is defined  aspartial_arho=frac12(rho L_a+L_arho), where rho is the parameterized density matrix. \n\nρ: Density matrix.\ndρ: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.\nrep: Representation of the SLD operator. Options can be: \"original\" (default) and \"eigen\" .\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.SLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.SLD","text":"SLD(ρ::Matrix{T}, dρ::Matrix{T}; rep=\"original\", eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen applied to the case of single parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.SMopt","page":"Base API","title":"QuanEstimationBase.SMopt","text":"SMopt(psi=nothing, M=nothing, seed=1234)\n\nState and control optimization.\n\npsi: Guessed probe state.\nM: Guessed projective measurement (a set of basis).\nseed: Random seed.\n\n\n\n\n\n","category":"type"},{"location":"api/BaseAPI/#QuanEstimationBase.StateOpt-Tuple{}","page":"Base API","title":"QuanEstimationBase.StateOpt","text":"StateOpt(psi=nothing, seed=1234)\n\nState optimization.\n\npsi: Guessed probe state.\nseed: Random seed.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.autoGRAPE-Tuple{}","page":"Base API","title":"QuanEstimationBase.autoGRAPE","text":"autoGRAPE(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)\n\nControl optimization algorithm: auto-GRAPE.\n\nmax_episode: The number of episodes.\nepsilon: Learning rate.\nbeta1: The exponential decay rate for the first moment estimates.\nbeta2: The exponential decay rate for the second moment estimates.\nAdam: Whether or not to use Adam for updating control coefficients.   \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.BCB-Tuple{Any, Any, Any}","page":"Base API","title":"QuanEstimationBase.BCB","text":"BCB(x, p, rho; W=nothing, eps=GLOBAL_EPS)\n\nCalculation of the minimum Bayesian cost with a quadratic cost function.\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\nrho: Parameterized density matrix.\nW: Weight matrix.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.BCFIM-Tuple{AbstractVector, Any, Any, Any}","page":"Base API","title":"QuanEstimationBase.BCFIM","text":"BCFIM(x::AbstractVector, p, rho, drho; M=nothing, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form mathcalI_mathrmBayes=int p(textbfx)mathcalImathrmdtextbfx with mathcalI the CFIM and p(textbfx) the prior distribution.\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.BCRB-Tuple{AbstractVector, Vararg{Any, 4}}","page":"Base API","title":"QuanEstimationBase.BCRB","text":"BCRB(x::AbstractVector, p, dp, rho, drho; M=nothing, b=nothing, db=nothing, btype=1, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian Cramer-Rao bound (BCRB).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\ndp: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\nb: Vector of biases of the form textbfb=(b(x_0)b(x_1)dots)^mathrmT.\ndb: Derivatives of b on the unknown parameters to be estimated, It should be expressed as textbfb=(partial_0 b(x_0)partial_1 b(x_1)dots)^mathrmT.\nbtype: Types of the BCRB. Options are 1, 2 and 3.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.BQCRB-Tuple{AbstractVector, Vararg{Any, 4}}","page":"Base API","title":"QuanEstimationBase.BQCRB","text":"BQCRB(x::AbstractVector, p, dp, rho, drho; b=nothing, db=nothing, LDtype=:SLD, btype=1, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian quantum Cramer-Rao bound (BQCRB).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\ndp: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nb: Vector of biases of the form textbfb=(b(x_0)b(x_1)dots)^mathrmT.\ndb: Derivatives of b on the unknown parameters to be estimated, It should be expressed as textbfb=(partial_0 b(x_0)partial_1 b(x_1)dots)^mathrmT.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".\nbtype: Types of the BCRB. Options are 1, 2 and 3.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.BQFIM-Tuple{AbstractVector, Any, Any, Any}","page":"Base API","title":"QuanEstimationBase.BQFIM","text":"BQFIM(x::AbstractVector, p, rho, drho; LDtype=:SLD, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form mathcalF_mathrmBayes=int p(textbfx)mathcalFmathrmdtextbfx with mathcalF the QFIM of all types and p(textbfx) the prior distribution.\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.Bayes-NTuple{4, Any}","page":"Base API","title":"QuanEstimationBase.Bayes","text":"Bayes(x, p, rho, y; M=nothing, savefile=false)\n\nBayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes’ rule and the estimated value of parameters obtained via the maximum a posteriori probability (MAP).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\nrho: Parameterized density matrix.\ny: The experimental results obtained in practice.\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\nsavefile: Whether or not to save all the posterior distributions. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.BayesCost-NTuple{5, Any}","page":"Base API","title":"QuanEstimationBase.BayesCost","text":"BayesCost(x, p, xest, rho, M; W=nothing, eps=GLOBAL_EPS)\n\nCalculation of the average Bayesian cost with a quadratic cost function.\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\nxest: The estimators.\nrho: Parameterized density matrix.\nM: A set of POVM.\nW: Weight matrix.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}, Any}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.CFIM","text":"CFIM(ρ::Matrix{T}, dρ::Vector{Matrix{T}}, M; eps=GLOBAL_EPS) where {T<:Complex}\n\nCalculate the classical Fisher information matrix (CFIM). \n\nρ: Density matrix.\ndρ: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.CFIM","text":"CFIM(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; M=nothing, eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen the set of POVM is not given. Calculate the CFIM with SIC-POVM. The SIC-POVM is generated from the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Any}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.CFIM","text":"CFIM(ρ::Matrix{T}, dρ::Matrix{T}, M; eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen applied to the case of single parameter. Calculate the classical Fisher information (CFI). \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.CFIM","text":"CFIM(ρ::Matrix{T}, dρ::Matrix{T}; eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen applied to the case of single parameter and the set of POVM is not given. Calculate the CFI with SIC-POVM. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.FIM-Union{Tuple{R}, Tuple{Vector{R}, Array{Vector{R}, 1}}} where R<:Real","page":"Base API","title":"QuanEstimationBase.FIM","text":"FIM(p::Vector{R}, dp::Vector{R}; eps=GLOBAL_EPS) where {R<:Real}\n\nCalculation of the classical Fisher information matrix for classical scenarios. \n\np: The probability distribution.\ndp: Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.FIM-Union{Tuple{R}, Tuple{Vector{R}, Vector{R}}} where R<:Real","page":"Base API","title":"QuanEstimationBase.FIM","text":"FIM(p::Vector{R}, dp::Vector{R}; eps=GLOBAL_EPS) where {R<:Real}\n\nWhen applied to the case of single parameter and the set of POVM is not given. Calculate the classical Fisher information for classical scenarios. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.FI_Expt-Tuple{Any, Any, Any}","page":"Base API","title":"QuanEstimationBase.FI_Expt","text":"FI_Expt(y1, y2, dx; ftype=:norm)\n\nCalculate the classical Fisher information (CFI) based on the experiment data.\n\ny1: Experimental data obtained at the truth value (x).\ny1: Experimental data obtained at x+dx.\ndx: A known small drift of the parameter.\nftype: The distribution the data follows. Options are: norm, gamma, rayleigh, and poisson.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.HCRB-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Base API","title":"QuanEstimationBase.HCRB","text":"HCRB(ρ::AbstractMatrix, dρ::AbstractVector, W::AbstractMatrix; eps=GLOBAL_EPS)\n\nCaltulate the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP).\n\nρ: Density matrix.\ndρ: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.\nW: Weight matrix.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.MLE-Tuple{Any, Any, Any}","page":"Base API","title":"QuanEstimationBase.MLE","text":"MLE(x, rho, y; M=nothing, savefile=false)\n\nBayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE).\n\nx: The regimes of the parameters for the integral.\nrho: Parameterized density matrix.\ny: The experimental results obtained in practice.\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\nsavefile: Whether or not to save all the posterior distributions. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.MeasurementOpt-Tuple{}","page":"Base API","title":"QuanEstimationBase.MeasurementOpt","text":"MeasurementOpt(mtype=:Projection, kwargs...)\n\nMeasurement optimization.\n\nmtype: The type of scenarios for the measurement optimization. Options are :Projection (default), :LC and :Rotation.\nkwargs...: keywords and the correponding default vaules. mtype=:Projection, mtype=:LC and mtype=:Rotation,   the kwargs... are M=nothing, B=nothing, POVM_basis=nothing, and s=nothing, POVM_basis=nothing, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.NHB-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Base API","title":"QuanEstimationBase.NHB","text":"NHB(ρ::AbstractMatrix, dρ::AbstractVector, W::AbstractMatrix)\n\nNagaoka-Hayashi bound (NHB) via the semidefinite program (SDP).\n\nρ: Density matrix.\ndρ: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.\nW: Weight matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.OBB-Tuple{AbstractVector, Vararg{Any, 5}}","page":"Base API","title":"QuanEstimationBase.OBB","text":"OBB(x::AbstractVector, p, dp, rho, drho, d2rho; LDtype=:SLD, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\ndp: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nd2rho: Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.QFIM","text":"QFIM(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; LDtype=:SLD, exportLD::Bool= false, eps=GLOBAL_EPS) where {T<:Complex}\n\nWhen applied to the case of single parameter. Calculation of the quantum Fisher information (QFI) for all types.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Complex","page":"Base API","title":"QuanEstimationBase.QFIM","text":"QFIM(ρ::Matrix{T}, dρ::Matrix{T}; LDtype=:SLD, exportLD::Bool= false, eps=GLOBAL_EPS) where {T<:Complex}\n\nCalculation of the quantum Fisher information (QFI) for all types. \n\nρ: Density matrix.\ndρ: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD.\nexportLD: export logarithmic derivatives apart from F.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QFIM_Gauss-Union{Tuple{VM}, Tuple{M}, Tuple{VV}, Tuple{V}, Tuple{V, VV, M, VM}} where {V, VV, M, VM<:(AbstractVecOrMat)}","page":"Base API","title":"QuanEstimationBase.QFIM_Gauss","text":"QFIM_Gauss(R̄::V, dR̄::VV, D::M, dD::VM) where {V,VV,M,VM<:AbstractVecOrMat}\n\nCalculate the SLD based quantum Fisher information matrix (QFIM) with gaussian states.  \n\nR̄ : First-order moment.\ndR̄: Derivatives of the first-order moment with respect to the unknown parameters to be estimated. For example, dR[1] is the derivative vector on the first parameter. \nD: Second-order moment.\ndD: Derivatives of the second-order moment with respect to the unknown parameters to be estimated. \neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QFIM_Kraus-Tuple{AbstractMatrix, AbstractVector, AbstractVector}","page":"Base API","title":"QuanEstimationBase.QFIM_Kraus","text":"QFIM_Kraus(ρ0::AbstractMatrix, K::AbstractVector, dK::AbstractVector; LDtype=:SLD, exportLD::Bool=false, eps=GLOBAL_EPS)\n\nCalculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types.\n\nρ0: Density matrix.\nK: Kraus operator(s).\ndK: Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD.\nexportLD: Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QVTB-Tuple{AbstractVector, Vararg{Any, 4}}","page":"Base API","title":"QuanEstimationBase.QVTB","text":"QVTB(x::AbstractVector, p, dp, rho, drho; LDtype=:SLD, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian version of Cramer-Rao bound in troduced by Van Trees (VTB).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\ndp: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nLDtype: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.QZZB-Tuple{AbstractVector, AbstractVector, AbstractVecOrMat}","page":"Base API","title":"QuanEstimationBase.QZZB","text":"QZZB(x::AbstractVector, p::AbstractVector, rho::AbstractVecOrMat; eps=GLOBAL_EPS)\n\nCalculation of the quantum Ziv-Zakai bound (QZZB).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\nrho: Parameterized density matrix.\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.SIC-Tuple{Int64}","page":"Base API","title":"QuanEstimationBase.SIC","text":"SIC(dim::Int64)\n\nGeneration of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM).\n\ndim: The dimension of the system.\n\nNote: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.SpinSqueezing-Tuple{AbstractMatrix}","page":"Base API","title":"QuanEstimationBase.SpinSqueezing","text":"SpinSqueezing(ρ::AbstractMatrix; basis=\"Dicke\", output=\"KU\")\n\nCalculate the spin squeezing parameter for the input density matrix. The basis can be \"Dicke\" for the Dicke basis, or \"Pauli\" for the Pauli basis. The output can be both \"KU\"(for spin squeezing defined by Kitagawa and Ueda) and \"WBIMH\"(for spin squeezing defined by Wineland et al.).\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.TargetTime-Tuple{Number, AbstractVector, Function, Vararg{Any}}","page":"Base API","title":"QuanEstimationBase.TargetTime","text":"TargetTime(f::Number, tspan::AbstractVector, func::Function, args...; kwargs...)\n\nCalculate the minimum time to reach a precision limit of given level. The func can be any objective function during the control optimization, e.g. QFIM, CFIM, HCRB, etc.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.VTB-Tuple{AbstractVector, Vararg{Any, 4}}","page":"Base API","title":"QuanEstimationBase.VTB","text":"VTB(x::AbstractVector, p, dp, rho, drho; M=nothing, eps=GLOBAL_EPS)\n\nCalculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB).\n\nx: The regimes of the parameters for the integral.\np: The prior distribution.\ndp: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.\nrho: Parameterized density matrix.\ndrho: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\nM: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\neps: Machine epsilon.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.evolve-Union{Tuple{Scheme{DensityMatrix, Kraus{KT, DKT, NK, NP}, M, E}}, Tuple{E}, Tuple{M}, Tuple{NP}, Tuple{NK}, Tuple{DKT}, Tuple{KT}} where {KT, DKT, NK, NP, M, E}","page":"Base API","title":"QuanEstimationBase.evolve","text":"evolve(dynamics::Kraus{dm})\n\nEvolution of density matrix under time-independent Hamiltonian without noise and controls.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.evolve-Union{Tuple{Scheme{QuanEstimationBase.Ket, Kraus{KT, DKT, NK, NP}, M, E}}, Tuple{E}, Tuple{M}, Tuple{NP}, Tuple{NK}, Tuple{DKT}, Tuple{KT}} where {KT, DKT, NK, NP, M, E}","page":"Base API","title":"QuanEstimationBase.evolve","text":"evolve(dynamics::Kraus{ket})\n\nEvolution of pure states under time-independent Hamiltonian without noise and controls\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.expm-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractMatrix}","page":"Base API","title":"QuanEstimationBase.expm","text":"expm(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractMatrix, dH::AbstractMatrix; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)\n\nWhen applied to the case of single parameter. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.expm-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractVector}","page":"Base API","title":"QuanEstimationBase.expm","text":"expm(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractMatrix, dH::AbstractVector; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)\n\nThe dynamics of a density matrix is of the form  partial_trho=-iHrho+sum_i gamma_ileft(Gamma_irhoGamma^dagger_i-frac12leftrhoGamma^dagger_i Gamma_i rightright), where rho is the evolved density matrix, H is the Hamiltonian of the system, Gamma_i and gamma_i are the imathrmth decay operator and the corresponding decay rate.\n\ntspan: Time length for the evolution.\nρ0: Initial state (density matrix).\nH0: Free Hamiltonian.\ndH: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.\ndecay: Decay operators and the corresponding decay rates. Its input rule is decay=[[Gamma_1, gamma_1], [Gamma_2, gamma_2],...], where Gamma_1 (Gamma_2) represents the decay operator and gamma_1 (gamma_2) is the corresponding decay rate.\nHc: Control Hamiltonians.\nctrl: Control coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.ode-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractMatrix}","page":"Base API","title":"QuanEstimationBase.ode","text":"ode(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractMatrix, dH::AbstractMatrix; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)\n\nWhen applied to the case of single parameter. \n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.ode-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractVector}","page":"Base API","title":"QuanEstimationBase.ode","text":"ode(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractVector, dH::AbstractVector; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)\n\nThe dynamics of a density matrix is of the form  partial_trho=-iHrho+sum_i gamma_ileft(Gamma_irhoGamma^dagger_i-frac12leftrhoGamma^dagger_i Gamma_i rightright), where rho is the evolved density matrix, H is the Hamiltonian of the system, Gamma_i and gamma_i are the imathrmth decay operator and the corresponding decay rate.\n\ntspan: Time length for the evolution.\nρ0: Initial state (density matrix).\nH0: Free Hamiltonian.\ndH: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.\ndecay: Decay operators and the corresponding decay rates. Its input rule is decay=[[Gamma_1, gamma_1], [Gamma_2, gamma_2],...], where Gamma_1 (Gamma_2) represents the decay operator and gamma_1 (gamma_2) is the corresponding decay rate.\nHc: Control Hamiltonians.\nctrl: Control coefficients.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.offline-Tuple{Adapt_MZI, Any}","page":"Base API","title":"QuanEstimationBase.offline","text":"offline(apt::Adapt_MZI, alg; target::Symbol=:sharpness, eps = GLOBAL_EPS, seed=1234)\n\nOffline adaptive phase estimation in the MZI.\n\napt: Adaptive MZI struct which contains x, p, and rho0.\nalg: The algorithms for searching the optimal tunable phase. Here, DE and PSO are available. \ntarget: Setting the target function for calculating the tunable phase. Options are: \"sharpness\" and \"MI\".\neps: Machine epsilon.\nseed: Random seed.\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.online-Tuple{Adapt_MZI}","page":"Base API","title":"QuanEstimationBase.online","text":"online(apt::Adapt_MZI; target::Symbol=:sharpness, output::String=\"phi\")\n\nOnline adaptive phase estimation in the MZI.\n\napt: Adaptive MZI struct which contains x, p, and rho0.\ntarget: Setting the target function for calculating the tunable phase. Options are: \"sharpness\" and \"MI\".\noutput: Choose the output variables. Options are: \"phi\" and \"dphi\".\n\n\n\n\n\n","category":"method"},{"location":"api/BaseAPI/#QuanEstimationBase.suN_generator-Tuple{Int64}","page":"Base API","title":"QuanEstimationBase.suN_generator","text":"suN_generator(n::Int64)\n\nGeneration of the SU(N) generators with N the dimension of the system.\n\nN: The dimension of the system.\n\n\n\n\n\n","category":"method"},{"location":"api/GeneralAPI/#General-API","page":"General API","title":"General API","text":"","category":"section"},{"location":"api/GeneralAPI/","page":"General API","title":"General API","text":"CurrentModule = QuanEstimationBase","category":"page"},{"location":"api/GeneralAPI/","page":"General API","title":"General API","text":"Modules = [QuanEstimationBase]","category":"page"},{"location":"#QuanEstimation.jl","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"QuanEstimation.jl is an open-source Julia framework for scheme evaluation and design in quantum parameter estimation.  It can be used either as an independent package or as the computational core of the Python-Julia package  QuanEstimation.","category":"page"},{"location":"#Key-Features","page":"QuanEstimation.jl","title":"Key Features","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"Comprehensive toolkit for quantum parameter estimation","category":"page"},{"location":"#Installation","page":"QuanEstimation.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"To install QuanEstimation.jl:","category":"page"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"using Pkg\nPkg.add(\"QuanEstimation\")","category":"page"},{"location":"#Quick-Start","page":"QuanEstimation.jl","title":"Quick Start","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"using QuanEstimation","category":"page"},{"location":"#Documentation","page":"QuanEstimation.jl","title":"Documentation","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"Explore our comprehensive documentation:","category":"page"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"Base API\nGeneral API\nNV Magnetometer API\nExamples","category":"page"},{"location":"#Citing-QuanEstimation.jl","page":"QuanEstimation.jl","title":"Citing QuanEstimation.jl","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"If you use QuanEstimation.jl in your research, please cite:","category":"page"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"[1] M. Zhang, H.-M. Yu, H. Yuan, X. Wang, R. Demkowicz-Dobrzański, and J. Liu,  QuanEstimation: An open-source toolkit for quantum parameter estimation,  Phys. Rev. Res. 4, 043057 (2022).","category":"page"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"[2] H.-M. Yu and J. Liu, QuanEstimation.jl: An open-source Julia framework for quantum parameter estimation,  Fundam. Res. (2025).","category":"page"},{"location":"#Contributing","page":"QuanEstimation.jl","title":"Contributing","text":"","category":"section"},{"location":"","page":"QuanEstimation.jl","title":"QuanEstimation.jl","text":"We welcome contributions! Please see our GitHub repository  for contribution guidelines.","category":"page"},{"location":"api/NVMagnetometerAPI/#NV-Magnetometer-API","page":"NV Magnetometer API","title":"NV Magnetometer API","text":"","category":"section"},{"location":"api/NVMagnetometerAPI/","page":"NV Magnetometer API","title":"NV Magnetometer API","text":"CurrentModule = NVMagnetometer","category":"page"},{"location":"api/NVMagnetometerAPI/","page":"NV Magnetometer API","title":"NV Magnetometer API","text":"Modules = [NVMagnetometer]","category":"page"}]
}
