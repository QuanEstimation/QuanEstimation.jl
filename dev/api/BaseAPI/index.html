<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base · QuanEstimation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../GeneralAPI/">QuanEstimation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../GeneralAPI/">General</a></li><li class="is-active"><a class="tocitem" href>Base</a></li><li><a class="tocitem" href="../NVMagnetometerAPI/">NVMagnetometer</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Base</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Base</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuanEstimation/QuanEstimation.jl/blob/main/docs/src/api/BaseAPI.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Base"><a class="docs-heading-anchor" href="#Base">Base</a><a id="Base-1"></a><a class="docs-heading-anchor-permalink" href="#Base" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.AD-Tuple{}" href="#QuanEstimationBase.AD-Tuple{}"><code>QuanEstimationBase.AD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AD(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)</code></pre><p>Optimization algorithm: AD.</p><ul><li><code>max_episode</code>: The number of episodes.</li><li><code>epsilon</code>: Learning rate.</li><li><code>beta1</code>: The exponential decay rate for the first moment estimates.</li><li><code>beta2</code>: The exponential decay rate for the second moment estimates.</li><li><code>Adam</code>: Whether or not to use Adam for updating control coefficients.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.CFIM_obj-Tuple{}" href="#QuanEstimationBase.CFIM_obj-Tuple{}"><code>QuanEstimationBase.CFIM_obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFIM_obj(;M=nothing, W=nothing, eps=GLOBAL_EPS)</code></pre><p>Choose CFI [<span>$\mathrm{Tr}(WI^{-1})$</span>] as the objective function with <span>$W$</span> the weight matrix and <span>$I$</span> the CFIM.</p><ul><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>W</code>: Weight matrix.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.CMopt" href="#QuanEstimationBase.CMopt"><code>QuanEstimationBase.CMopt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CMopt(ctrl=nothing, M=nothing, ctrl_bound=[-Inf, Inf], seed=1234)</code></pre><p>Control and measurement optimization.</p><ul><li><code>ctrl</code>: Guessed control coefficients.</li><li><code>M</code>: Guessed projective measurement (a set of basis)</li><li><code>ctrl_bound</code>: Lower and upper bounds of the control coefficients.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.ControlOpt-Tuple{}" href="#QuanEstimationBase.ControlOpt-Tuple{}"><code>QuanEstimationBase.ControlOpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ControlOpt(ctrl=nothing, ctrl_bound=[-Inf, Inf], seed=1234)</code></pre><p>Control optimization.</p><ul><li><code>ctrl</code>: Guessed control coefficients.</li><li><code>ctrl_bound</code>: Lower and upper bounds of the control coefficients.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.DDPG-Tuple{}" href="#QuanEstimationBase.DDPG-Tuple{}"><code>QuanEstimationBase.DDPG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DDPG(;max_episode::Int=500, layer_num::Int=3, layer_dim::Int=200, seed::Number=1234)</code></pre><p>Optimization algorithm: DE.</p><ul><li><code>max_episode</code>: The number of populations.</li><li><code>layer_num</code>: The number of layers (include the input and output layer).</li><li><code>layer_dim</code>: The number of neurons in the hidden layer.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.DE-Tuple{}" href="#QuanEstimationBase.DE-Tuple{}"><code>QuanEstimationBase.DE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DE(;max_episode::Number=1000, p_num::Number=10, ini_population=nothing, c::Number=1.0, cr::Number=0.5, seed::Number=1234)</code></pre><p>Optimization algorithm: DE.</p><ul><li><code>max_episode</code>: The number of populations.</li><li><code>p_num</code>: The number of particles. </li><li><code>ini_population</code>: Initial guesses of the optimization variables.</li><li><code>c</code>: Mutation constant.</li><li><code>cr</code>: Crossover constant.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.GRAPE-Tuple{}" href="#QuanEstimationBase.GRAPE-Tuple{}"><code>QuanEstimationBase.GRAPE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GRAPE(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)</code></pre><p>Control optimization algorithm: GRAPE.</p><ul><li><code>max_episode</code>: The number of episodes.</li><li><code>epsilon</code>: Learning rate.</li><li><code>beta1</code>: The exponential decay rate for the first moment estimates.</li><li><code>beta2</code>: The exponential decay rate for the second moment estimates.</li><li><code>Adam</code>: Whether or not to use Adam for updating control coefficients.   </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.HCRB_obj-Tuple{}" href="#QuanEstimationBase.HCRB_obj-Tuple{}"><code>QuanEstimationBase.HCRB_obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HCRB_obj(;W=nothing, eps=GLOBAL_EPS)</code></pre><p>Choose HCRB as the objective function. </p><ul><li><code>W</code>: Weight matrix.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.LLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex" href="#QuanEstimationBase.LLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex"><code>QuanEstimationBase.LLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LLD(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; rep=&quot;original&quot;, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>Calculate the left logarrithmic derivatives (LLDs). The LLD operator is defined as <span>$\partial_{a}\rho=\mathcal{R}_a^{\dagger}\rho$</span>, where ρ is the parameterized density matrix.    </p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li><li><code>rep</code>: Representation of the LLD operator. Options can be: &quot;original&quot; (default) and &quot;eigen&quot;.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.LLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex" href="#QuanEstimationBase.LLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex"><code>QuanEstimationBase.LLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LLD(ρ::Matrix{T}, dρ::Matrix{T}; rep=&quot;original&quot;, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When applied to the case of single parameter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.NM-Tuple{}" href="#QuanEstimationBase.NM-Tuple{}"><code>QuanEstimationBase.NM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NM(;max_episode::Int=1000, p_num::Int=10, nelder_mead=nothing, ar::Number=1.0, ae::Number=2.0, ac::Number=0.5, as0::Number=0.5, seed::Number=1234)</code></pre><p>State optimization algorithm: NM.</p><ul><li><code>max_episode</code>: The number of populations.</li><li><code>p_num</code>: The number of the input states.</li><li><code>nelder_mead</code>: Initial guesses of the optimization variables.</li><li><code>ar</code>: Reflection constant.</li><li><code>ae</code>: Expansion constant.</li><li><code>ac</code>: Constraction constant.</li><li><code>as0</code>: Shrink constant.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.PSO-Tuple{}" href="#QuanEstimationBase.PSO-Tuple{}"><code>QuanEstimationBase.PSO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PSO(;max_episode::Union{T,Vector{T}} where {T&lt;:Int}=[1000, 100], p_num::Number=10, ini_particle=nothing, c0::Number=1.0, c1::Number=2.0, c2::Number=2.0, seed::Number=1234)</code></pre><p>Optimization algorithm: PSO.</p><ul><li><code>max_episode</code>: The number of episodes, it accepts both integer and array with two elements.</li><li><code>p_num</code>: The number of particles. </li><li><code>ini_particle</code>: Initial guesses of the optimization variables.</li><li><code>c0</code>: The damping factor that assists convergence, also known as inertia weight.</li><li><code>c1</code>: The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor.</li><li><code>c2</code>: The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QFIM_obj-Tuple{}" href="#QuanEstimationBase.QFIM_obj-Tuple{}"><code>QuanEstimationBase.QFIM_obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFIM_obj(;W=nothing, eps=GLOBAL_EPS, LDtype::Symbol=:SLD)</code></pre><p>Choose QFI [<span>$\mathrm{Tr}(WF^{-1})$</span>] as the objective function with <span>$W$</span> the weight matrix and <span>$F$</span> the QFIM.</p><ul><li><code>W</code>: Weight matrix.</li><li><code>eps</code>: Machine epsilon.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.RI-Tuple{}" href="#QuanEstimationBase.RI-Tuple{}"><code>QuanEstimationBase.RI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RI(;max_episode::Int=300, seed::Number=1234)</code></pre><p>State optimization algorithm: RI.</p><ul><li><code>max_episode</code>: The number of episodes.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.RLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex" href="#QuanEstimationBase.RLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex"><code>QuanEstimationBase.RLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RLD(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; rep=&quot;original&quot;, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>Calculate the right logarrithmic derivatives (RLDs). The RLD operator is defined as  <span>$\partial_{a}\rho=\rho \mathcal{R}_a$</span>, where <span>$\rho$</span> is the parameterized density matrix.  </p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li><li><code>rep</code>: Representation of the RLD operator. Options can be: &quot;original&quot; (default) and &quot;eigen&quot;.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.RLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex" href="#QuanEstimationBase.RLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex"><code>QuanEstimationBase.RLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RLD(ρ::Matrix{T}, dρ::Matrix{T}; rep=&quot;original&quot;, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When applied to the case of single parameter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SCMopt" href="#QuanEstimationBase.SCMopt"><code>QuanEstimationBase.SCMopt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SCMopt(psi=nothing, ctrl=nothing, M=nothing, ctrl_bound=[-Inf, Inf], seed=1234)</code></pre><p>State, control and measurement optimization.</p><ul><li><code>psi</code>: Guessed probe state.</li><li><code>ctrl</code>: Guessed control coefficients.</li><li><code>M</code>: Guessed projective measurement (a set of basis).</li><li><code>ctrl_bound</code>:  Lower and upper bounds of the control coefficients.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SCopt" href="#QuanEstimationBase.SCopt"><code>QuanEstimationBase.SCopt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SCopt(psi=nothing, ctrl=nothing, ctrl_bound=[-Inf, Inf], seed=1234)</code></pre><p>State and control optimization.</p><ul><li><code>psi</code>: Guessed probe state.</li><li><code>ctrl</code>: Guessed control coefficients.</li><li><code>ctrl_bound</code>: Lower and upper bounds of the control coefficients.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex" href="#QuanEstimationBase.SLD-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex"><code>QuanEstimationBase.SLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SLD(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; rep=&quot;original&quot;, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>Calculate the symmetric logarrithmic derivatives (SLDs). The SLD operator <span>$L_a$</span> is defined  as<span>$\partial_{a}\rho=\frac{1}{2}(\rho L_{a}+L_{a}\rho)$</span>, where <span>$\rho$</span> is the parameterized density matrix. </p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li><li><code>rep</code>: Representation of the SLD operator. Options can be: &quot;original&quot; (default) and &quot;eigen&quot; .</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex" href="#QuanEstimationBase.SLD-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex"><code>QuanEstimationBase.SLD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SLD(ρ::Matrix{T}, dρ::Matrix{T}; rep=&quot;original&quot;, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When applied to the case of single parameter.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SMopt" href="#QuanEstimationBase.SMopt"><code>QuanEstimationBase.SMopt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SMopt(psi=nothing, M=nothing, seed=1234)</code></pre><p>State and control optimization.</p><ul><li><code>psi</code>: Guessed probe state.</li><li><code>M</code>: Guessed projective measurement (a set of basis).</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.StateOpt-Tuple{}" href="#QuanEstimationBase.StateOpt-Tuple{}"><code>QuanEstimationBase.StateOpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StateOpt(psi=nothing, seed=1234)</code></pre><p>State optimization.</p><ul><li><code>psi</code>: Guessed probe state.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.autoGRAPE-Tuple{}" href="#QuanEstimationBase.autoGRAPE-Tuple{}"><code>QuanEstimationBase.autoGRAPE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoGRAPE(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)</code></pre><p>Control optimization algorithm: auto-GRAPE.</p><ul><li><code>max_episode</code>: The number of episodes.</li><li><code>epsilon</code>: Learning rate.</li><li><code>beta1</code>: The exponential decay rate for the first moment estimates.</li><li><code>beta2</code>: The exponential decay rate for the second moment estimates.</li><li><code>Adam</code>: Whether or not to use Adam for updating control coefficients.   </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.BCB-Tuple{Any, Any, Any}" href="#QuanEstimationBase.BCB-Tuple{Any, Any, Any}"><code>QuanEstimationBase.BCB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BCB(x, p, rho; W=nothing, eps=GLOBAL_EPS)</code></pre><p>Calculation of the minimum Bayesian cost with a quadratic cost function.</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>W</code>: Weight matrix.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.BCFIM-Tuple{AbstractVector, Any, Any, Any}" href="#QuanEstimationBase.BCFIM-Tuple{AbstractVector, Any, Any, Any}"><code>QuanEstimationBase.BCFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BCFIM(x::AbstractVector, p, rho, drho; M=nothing, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form <span>$\mathcal{I}_{\mathrm{Bayes}}=\int p(\textbf{x})\mathcal{I}\mathrm{d}\textbf{x}$</span> with <span>$\mathcal{I}$</span> the CFIM and <span>$p(\textbf{x})$</span> the prior distribution.</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.BCRB-Tuple{AbstractVector, Vararg{Any, 4}}" href="#QuanEstimationBase.BCRB-Tuple{AbstractVector, Vararg{Any, 4}}"><code>QuanEstimationBase.BCRB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BCRB(x::AbstractVector, p, dp, rho, drho; M=nothing, b=nothing, db=nothing, btype=1, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian Cramer-Rao bound (BCRB).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>b</code>: Vector of biases of the form <span>$\textbf{b}=(b(x_0),b(x_1),\dots)^{\mathrm{T}}$</span>.</li><li><code>db</code>: Derivatives of b on the unknown parameters to be estimated, It should be expressed as <span>$\textbf{b}&#39;=(\partial_0 b(x_0),\partial_1 b(x_1),\dots)^{\mathrm{T}}$</span>.</li><li><code>btype</code>: Types of the BCRB. Options are 1, 2 and 3.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.BQCRB-Tuple{AbstractVector, Vararg{Any, 4}}" href="#QuanEstimationBase.BQCRB-Tuple{AbstractVector, Vararg{Any, 4}}"><code>QuanEstimationBase.BQCRB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BQCRB(x::AbstractVector, p, dp, rho, drho; b=nothing, db=nothing, LDtype=:SLD, btype=1, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>b</code>: Vector of biases of the form <span>$\textbf{b}=(b(x_0),b(x_1),\dots)^{\mathrm{T}}$</span>.</li><li><code>db</code>: Derivatives of b on the unknown parameters to be estimated, It should be expressed as <span>$\textbf{b}&#39;=(\partial_0 b(x_0),\partial_1 b(x_1),\dots)^{\mathrm{T}}$</span>.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are &quot;SLD&quot; (default), &quot;RLD&quot; and &quot;LLD&quot;.</li><li><code>btype</code>: Types of the BCRB. Options are 1, 2 and 3.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.BQFIM-Tuple{AbstractVector, Any, Any, Any}" href="#QuanEstimationBase.BQFIM-Tuple{AbstractVector, Any, Any, Any}"><code>QuanEstimationBase.BQFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BQFIM(x::AbstractVector, p, rho, drho; LDtype=:SLD, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form <span>$\mathcal{F}_{\mathrm{Bayes}}=\int p(\textbf{x})\mathcal{F}\mathrm{d}\textbf{x}$</span> with <span>$\mathcal{F}$</span> the QFIM of all types and <span>$p(\textbf{x})$</span> the prior distribution.</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are &quot;SLD&quot; (default), &quot;RLD&quot; and &quot;LLD&quot;.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.Bayes-NTuple{4, Any}" href="#QuanEstimationBase.Bayes-NTuple{4, Any}"><code>QuanEstimationBase.Bayes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Bayes(x, p, rho, y; M=nothing, savefile=false)</code></pre><p>Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes’ rule and the estimated value of parameters obtained via the maximum a posteriori probability (MAP).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>y</code>: The experimental results obtained in practice.</li><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>savefile</code>: Whether or not to save all the posterior distributions. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.BayesCost-NTuple{5, Any}" href="#QuanEstimationBase.BayesCost-NTuple{5, Any}"><code>QuanEstimationBase.BayesCost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BayesCost(x, p, xest, rho, M; W=nothing, eps=GLOBAL_EPS)</code></pre><p>Calculation of the average Bayesian cost with a quadratic cost function.</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>xest</code>: The estimators.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>M</code>: A set of POVM.</li><li><code>W</code>: Weight matrix.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}, Any}} where T&lt;:Complex" href="#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}, Any}} where T&lt;:Complex"><code>QuanEstimationBase.CFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFIM(ρ::Matrix{T}, dρ::Vector{Matrix{T}}, M; eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>Calculate the classical Fisher information matrix (CFIM). </p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex" href="#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex"><code>QuanEstimationBase.CFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFIM(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; M=nothing, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When the set of POVM is not given. Calculate the CFIM with SIC-POVM. The SIC-POVM is generated from the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from <a href="http://www.physics.umb.edu/Research/QBism/solutions.html">here</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Any}} where T&lt;:Complex" href="#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Any}} where T&lt;:Complex"><code>QuanEstimationBase.CFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFIM(ρ::Matrix{T}, dρ::Matrix{T}, M; eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When applied to the case of single parameter. Calculate the classical Fisher information (CFI). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex" href="#QuanEstimationBase.CFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex"><code>QuanEstimationBase.CFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFIM(ρ::Matrix{T}, dρ::Matrix{T}; eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When applied to the case of single parameter and the set of POVM is not given. Calculate the CFI with SIC-POVM. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.FIM-Union{Tuple{R}, Tuple{Vector{R}, Array{Vector{R}, 1}}} where R&lt;:Real" href="#QuanEstimationBase.FIM-Union{Tuple{R}, Tuple{Vector{R}, Array{Vector{R}, 1}}} where R&lt;:Real"><code>QuanEstimationBase.FIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FIM(p::Vector{R}, dp::Vector{R}; eps=GLOBAL_EPS) where {R&lt;:Real}</code></pre><p>Calculation of the classical Fisher information matrix for classical scenarios. </p><ul><li><code>p</code>: The probability distribution.</li><li><code>dp</code>: Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.FIM-Union{Tuple{R}, Tuple{Vector{R}, Vector{R}}} where R&lt;:Real" href="#QuanEstimationBase.FIM-Union{Tuple{R}, Tuple{Vector{R}, Vector{R}}} where R&lt;:Real"><code>QuanEstimationBase.FIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FIM(p::Vector{R}, dp::Vector{R}; eps=GLOBAL_EPS) where {R&lt;:Real}</code></pre><p>When applied to the case of single parameter and the set of POVM is not given. Calculate the classical Fisher information for classical scenarios. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.FI_Expt-Tuple{Any, Any, Any}" href="#QuanEstimationBase.FI_Expt-Tuple{Any, Any, Any}"><code>QuanEstimationBase.FI_Expt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FI_Expt(y1, y2, dx; ftype=:norm)</code></pre><p>Calculate the classical Fisher information (CFI) based on the experiment data.</p><ul><li><code>y1</code>: Experimental data obtained at the truth value (x).</li><li><code>y1</code>: Experimental data obtained at x+dx.</li><li><code>dx</code>: A known small drift of the parameter.</li><li><code>ftype</code>: The distribution the data follows. Options are: norm, gamma, rayleigh, and poisson.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.HCRB-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}" href="#QuanEstimationBase.HCRB-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>QuanEstimationBase.HCRB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HCRB(ρ::AbstractMatrix, dρ::AbstractVector, W::AbstractMatrix; eps=GLOBAL_EPS)</code></pre><p>Caltulate the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP).</p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.</li><li><code>W</code>: Weight matrix.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.MLE-Tuple{Any, Any, Any}" href="#QuanEstimationBase.MLE-Tuple{Any, Any, Any}"><code>QuanEstimationBase.MLE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MLE(x, rho, y; M=nothing, savefile=false)</code></pre><p>Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>y</code>: The experimental results obtained in practice.</li><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>savefile</code>: Whether or not to save all the posterior distributions. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.MeasurementOpt-Tuple{}" href="#QuanEstimationBase.MeasurementOpt-Tuple{}"><code>QuanEstimationBase.MeasurementOpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MeasurementOpt(mtype=:Projection, kwargs...)</code></pre><p>Measurement optimization.</p><ul><li><code>mtype</code>: The type of scenarios for the measurement optimization. Options are <code>:Projection</code> (default), <code>:LC</code> and <code>:Rotation</code>.</li><li><code>kwargs...</code>: keywords and the correponding default vaules. <code>mtype=:Projection</code>, <code>mtype=:LC</code> and <code>mtype=:Rotation</code>,   the <code>kwargs...</code> are <code>M=nothing</code>, <code>B=nothing, POVM_basis=nothing</code>, and <code>s=nothing, POVM_basis=nothing</code>, respectively.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.NHB-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}" href="#QuanEstimationBase.NHB-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>QuanEstimationBase.NHB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NHB(ρ::AbstractMatrix, dρ::AbstractVector, W::AbstractMatrix)</code></pre><p>Nagaoka-Hayashi bound (NHB) via the semidefinite program (SDP).</p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.</li><li><code>W</code>: Weight matrix.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.OBB-Tuple{AbstractVector, Vararg{Any, 5}}" href="#QuanEstimationBase.OBB-Tuple{AbstractVector, Vararg{Any, 5}}"><code>QuanEstimationBase.OBB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OBB(x::AbstractVector, p, dp, rho, drho, d2rho; LDtype=:SLD, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>d2rho</code>: Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are &quot;SLD&quot; (default), &quot;RLD&quot; and &quot;LLD&quot;.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex" href="#QuanEstimationBase.QFIM-Union{Tuple{T}, Tuple{Matrix{T}, Array{Matrix{T}, 1}}} where T&lt;:Complex"><code>QuanEstimationBase.QFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFIM(ρ::Matrix{T}, dρ::Vector{Matrix{T}}; LDtype=:SLD, exportLD::Bool= false, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>When applied to the case of single parameter. Calculation of the quantum Fisher information (QFI) for all types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex" href="#QuanEstimationBase.QFIM-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T&lt;:Complex"><code>QuanEstimationBase.QFIM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFIM(ρ::Matrix{T}, dρ::Matrix{T}; LDtype=:SLD, exportLD::Bool= false, eps=GLOBAL_EPS) where {T&lt;:Complex}</code></pre><p>Calculation of the quantum Fisher information (QFI) for all types. </p><ul><li><code>ρ</code>: Density matrix.</li><li><code>dρ</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.</li><li><code>exportLD</code>: export logarithmic derivatives apart from F.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QFIM_Gauss-Union{Tuple{VM}, Tuple{M}, Tuple{VV}, Tuple{V}, Tuple{V, VV, M, VM}} where {V, VV, M, VM&lt;:(AbstractVecOrMat)}" href="#QuanEstimationBase.QFIM_Gauss-Union{Tuple{VM}, Tuple{M}, Tuple{VV}, Tuple{V}, Tuple{V, VV, M, VM}} where {V, VV, M, VM&lt;:(AbstractVecOrMat)}"><code>QuanEstimationBase.QFIM_Gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFIM_Gauss(R̄::V, dR̄::VV, D::M, dD::VM) where {V,VV,M,VM&lt;:AbstractVecOrMat}</code></pre><p>Calculate the SLD based quantum Fisher information matrix (QFIM) with gaussian states.  </p><ul><li><code>R̄</code> : First-order moment.</li><li><code>dR̄</code>: Derivatives of the first-order moment with respect to the unknown parameters to be estimated. For example, dR[1] is the derivative vector on the first parameter. </li><li><code>D</code>: Second-order moment.</li><li><code>dD</code>: Derivatives of the second-order moment with respect to the unknown parameters to be estimated. </li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QFIM_Kraus-Tuple{AbstractMatrix, AbstractVector, AbstractVector}" href="#QuanEstimationBase.QFIM_Kraus-Tuple{AbstractMatrix, AbstractVector, AbstractVector}"><code>QuanEstimationBase.QFIM_Kraus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QFIM_Kraus(ρ0::AbstractMatrix, K::AbstractVector, dK::AbstractVector; LDtype=:SLD, exportLD::Bool=false, eps=GLOBAL_EPS)</code></pre><p>Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types.</p><ul><li><code>ρ0</code>: Density matrix.</li><li><code>K</code>: Kraus operator(s).</li><li><code>dK</code>: Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.</li><li><code>exportLD</code>: Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QVTB-Tuple{AbstractVector, Vararg{Any, 4}}" href="#QuanEstimationBase.QVTB-Tuple{AbstractVector, Vararg{Any, 4}}"><code>QuanEstimationBase.QVTB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QVTB(x::AbstractVector, p, dp, rho, drho; LDtype=:SLD, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian version of Cramer-Rao bound in troduced by Van Trees (VTB).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are &quot;SLD&quot; (default), &quot;RLD&quot; and &quot;LLD&quot;.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.QZZB-Tuple{AbstractVector, AbstractVector, AbstractVecOrMat}" href="#QuanEstimationBase.QZZB-Tuple{AbstractVector, AbstractVector, AbstractVecOrMat}"><code>QuanEstimationBase.QZZB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QZZB(x::AbstractVector, p::AbstractVector, rho::AbstractVecOrMat; eps=GLOBAL_EPS)</code></pre><p>Calculation of the quantum Ziv-Zakai bound (QZZB).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SIC-Tuple{Int64}" href="#QuanEstimationBase.SIC-Tuple{Int64}"><code>QuanEstimationBase.SIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SIC(dim::Int64)</code></pre><p>Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM).</p><ul><li><code>dim</code>: The dimension of the system.</li></ul><p>Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from <a href="http://www.physics.umb.edu/Research/QBism/solutions.html">here</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.SpinSqueezing-Tuple{AbstractMatrix}" href="#QuanEstimationBase.SpinSqueezing-Tuple{AbstractMatrix}"><code>QuanEstimationBase.SpinSqueezing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SpinSqueezing(ρ::AbstractMatrix; basis=&quot;Dicke&quot;, output=&quot;KU&quot;)</code></pre><p>Calculate the spin squeezing parameter for the input density matrix. The <code>basis</code> can be <code>&quot;Dicke&quot;</code> for the Dicke basis, or <code>&quot;Pauli&quot;</code> for the Pauli basis. The <code>output</code> can be both <code>&quot;KU&quot;</code>(for spin squeezing defined by Kitagawa and Ueda) and <code>&quot;WBIMH&quot;</code>(for spin squeezing defined by Wineland et al.).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.TargetTime-Tuple{Number, AbstractVector, Function, Vararg{Any}}" href="#QuanEstimationBase.TargetTime-Tuple{Number, AbstractVector, Function, Vararg{Any}}"><code>QuanEstimationBase.TargetTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TargetTime(f::Number, tspan::AbstractVector, func::Function, args...; kwargs...)</code></pre><p>Calculate the minimum time to reach a precision limit of given level. The <code>func</code> can be any objective function during the control optimization, e.g. QFIM, CFIM, HCRB, etc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.VTB-Tuple{AbstractVector, Vararg{Any, 4}}" href="#QuanEstimationBase.VTB-Tuple{AbstractVector, Vararg{Any, 4}}"><code>QuanEstimationBase.VTB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VTB(x::AbstractVector, p, dp, rho, drho; M=nothing, eps=GLOBAL_EPS)</code></pre><p>Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB).</p><ul><li><code>x</code>: The regimes of the parameters for the integral.</li><li><code>p</code>: The prior distribution.</li><li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li><li><code>rho</code>: Parameterized density matrix.</li><li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li><li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li><li><code>eps</code>: Machine epsilon.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.evolve-Union{Tuple{Scheme{DensityMatrix, Kraus{KT, DKT, NK, NP}, M, E}}, Tuple{E}, Tuple{M}, Tuple{NP}, Tuple{NK}, Tuple{DKT}, Tuple{KT}} where {KT, DKT, NK, NP, M, E}" href="#QuanEstimationBase.evolve-Union{Tuple{Scheme{DensityMatrix, Kraus{KT, DKT, NK, NP}, M, E}}, Tuple{E}, Tuple{M}, Tuple{NP}, Tuple{NK}, Tuple{DKT}, Tuple{KT}} where {KT, DKT, NK, NP, M, E}"><code>QuanEstimationBase.evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve(dynamics::Kraus{dm})</code></pre><p>Evolution of density matrix under time-independent Hamiltonian without noise and controls.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.evolve-Union{Tuple{Scheme{QuanEstimationBase.Ket, Kraus{KT, DKT, NK, NP}, M, E}}, Tuple{E}, Tuple{M}, Tuple{NP}, Tuple{NK}, Tuple{DKT}, Tuple{KT}} where {KT, DKT, NK, NP, M, E}" href="#QuanEstimationBase.evolve-Union{Tuple{Scheme{QuanEstimationBase.Ket, Kraus{KT, DKT, NK, NP}, M, E}}, Tuple{E}, Tuple{M}, Tuple{NP}, Tuple{NK}, Tuple{DKT}, Tuple{KT}} where {KT, DKT, NK, NP, M, E}"><code>QuanEstimationBase.evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolve(dynamics::Kraus{ket})</code></pre><p>Evolution of pure states under time-independent Hamiltonian without noise and controls</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.expm-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractMatrix}" href="#QuanEstimationBase.expm-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractMatrix}"><code>QuanEstimationBase.expm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expm(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractMatrix, dH::AbstractMatrix; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)</code></pre><p>When applied to the case of single parameter. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.expm-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractVector}" href="#QuanEstimationBase.expm-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractVector}"><code>QuanEstimationBase.expm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expm(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractMatrix, dH::AbstractVector; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)</code></pre><p>The dynamics of a density matrix is of the form  <span>$\partial_t\rho=-i[H,\rho]+\sum_i \gamma_i\left(\Gamma_i\rho\Gamma^{\dagger}_i-\frac{1}{2}\left\{\rho,\Gamma^{\dagger}_i \Gamma_i \right\}\right)$</span>, where <span>$\rho$</span> is the evolved density matrix, <span>$H$</span> is the Hamiltonian of the system, <span>$\Gamma_i$</span> and <span>$\gamma_i$</span> are the <span>$i\mathrm{th}$</span> decay operator and the corresponding decay rate.</p><ul><li><code>tspan</code>: Time length for the evolution.</li><li><code>ρ0</code>: Initial state (density matrix).</li><li><code>H0</code>: Free Hamiltonian.</li><li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.</li><li><code>decay</code>: Decay operators and the corresponding decay rates. Its input rule is decay=[[<span>$\Gamma_1$</span>, <span>$\gamma_1$</span>], [<span>$\Gamma_2$</span>, <span>$\gamma_2$</span>],...], where <span>$\Gamma_1$</span> <span>$(\Gamma_2)$</span> represents the decay operator and <span>$\gamma_1$</span> <span>$(\gamma_2)$</span> is the corresponding decay rate.</li><li><code>Hc</code>: Control Hamiltonians.</li><li><code>ctrl</code>: Control coefficients.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.ode-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractMatrix}" href="#QuanEstimationBase.ode-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractMatrix}"><code>QuanEstimationBase.ode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ode(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractMatrix, dH::AbstractMatrix; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)</code></pre><p>When applied to the case of single parameter. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.ode-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractVector}" href="#QuanEstimationBase.ode-Tuple{AbstractVector, AbstractMatrix, AbstractVecOrMat, AbstractVector}"><code>QuanEstimationBase.ode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ode(tspan::AbstractVector, ρ0::AbstractMatrix, H0::AbstractVector, dH::AbstractVector; decay::Union{AbstractVector, Nothing}=nothing, Hc::Union{AbstractVector, Nothing}=nothing, ctrl::Union{AbstractVector, Nothing}=nothing)</code></pre><p>The dynamics of a density matrix is of the form  <span>$\partial_t\rho=-i[H,\rho]+\sum_i \gamma_i\left(\Gamma_i\rho\Gamma^{\dagger}_i-\frac{1}{2}\left\{\rho,\Gamma^{\dagger}_i \Gamma_i \right\}\right)$</span>, where <span>$\rho$</span> is the evolved density matrix, <span>$H$</span> is the Hamiltonian of the system, <span>$\Gamma_i$</span> and <span>$\gamma_i$</span> are the <span>$i\mathrm{th}$</span> decay operator and the corresponding decay rate.</p><ul><li><code>tspan</code>: Time length for the evolution.</li><li><code>ρ0</code>: Initial state (density matrix).</li><li><code>H0</code>: Free Hamiltonian.</li><li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.</li><li><code>decay</code>: Decay operators and the corresponding decay rates. Its input rule is decay=[[<span>$\Gamma_1$</span>, <span>$\gamma_1$</span>], [<span>$\Gamma_2$</span>, <span>$\gamma_2$</span>],...], where <span>$\Gamma_1$</span> <span>$(\Gamma_2)$</span> represents the decay operator and <span>$\gamma_1$</span> <span>$(\gamma_2)$</span> is the corresponding decay rate.</li><li><code>Hc</code>: Control Hamiltonians.</li><li><code>ctrl</code>: Control coefficients.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.offline-Tuple{Adapt_MZI, Any}" href="#QuanEstimationBase.offline-Tuple{Adapt_MZI, Any}"><code>QuanEstimationBase.offline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offline(apt::Adapt_MZI, alg; target::Symbol=:sharpness, eps = GLOBAL_EPS, seed=1234)</code></pre><p>Offline adaptive phase estimation in the MZI.</p><ul><li><code>apt</code>: Adaptive MZI struct which contains <code>x</code>, <code>p</code>, and <code>rho0</code>.</li><li><code>alg</code>: The algorithms for searching the optimal tunable phase. Here, DE and PSO are available. </li><li><code>target</code>: Setting the target function for calculating the tunable phase. Options are: &quot;sharpness&quot; and &quot;MI&quot;.</li><li><code>eps</code>: Machine epsilon.</li><li><code>seed</code>: Random seed.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.online-Tuple{Adapt_MZI}" href="#QuanEstimationBase.online-Tuple{Adapt_MZI}"><code>QuanEstimationBase.online</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">online(apt::Adapt_MZI; target::Symbol=:sharpness, output::String=&quot;phi&quot;)</code></pre><p>Online adaptive phase estimation in the MZI.</p><ul><li><code>apt</code>: Adaptive MZI struct which contains x, p, and rho0.</li><li><code>target</code>: Setting the target function for calculating the tunable phase. Options are: &quot;sharpness&quot; and &quot;MI&quot;.</li><li><code>output</code>: Choose the output variables. Options are: &quot;phi&quot; and &quot;dphi&quot;.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuanEstimationBase.suN_generator-Tuple{Int64}" href="#QuanEstimationBase.suN_generator-Tuple{Int64}"><code>QuanEstimationBase.suN_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">suN_generator(n::Int64)</code></pre><p>Generation of the SU(<span>$N$</span>) generators with <span>$N$</span> the dimension of the system.</p><ul><li><code>N</code>: The dimension of the system.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GeneralAPI/">« General</a><a class="docs-footer-nextpage" href="../NVMagnetometerAPI/">NVMagnetometer »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 August 2025 07:29">Friday 15 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
